<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SSWAP Mediator – Cottage Booking Service</title>
  <link rel="stylesheet" href="{{ url_for('static', path='styles.css') }}">
  <style>
    .intro {
      margin: 12px 0 24px;
      color: #4a5568;
      line-height: 1.5;
    }
    .mediatorGrid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 20px;
      align-items: start;
    }
    .mediatorPanel {
      border: 1px solid #e4e7ec;
      border-radius: 14px;
      padding: 18px;
      background: #fdfefe;
      display: flex;
      flex-direction: column;
      gap: 14px;
    }
    .mediatorPanel h3 {
      margin: 0;
      color: #0a2540;
    }
    .statusLine {
      font-weight: 600;
      color: #0a2540;
      min-height: 1.2rem;
    }
    table.alignment {
      width: 100%;
      border-collapse: collapse;
      font-size: .9rem;
    }
    table.alignment th,
    table.alignment td {
      border: 1px solid #e7ebf2;
      padding: 7px 8px;
      text-align: left;
    }
    table.alignment th {
      text-transform: uppercase;
      font-size: .75rem;
      letter-spacing: .05em;
      background: #f5f7fb;
    }
    table.alignment tr.lowConfidence td {
      background: #fff8e6;
    }
    pre.mono {
      font-family: ui-monospace, Menlo, Consolas, monospace;
      background: #0a2540;
      color: #e2e8f0;
      padding: 12px;
      border-radius: 12px;
      margin-top: 12px;
      min-height: 220px;
      overflow: auto;
    }
    .twoCol {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
    }
  </style>
</head>
<body>
  <header class="topbar">
    <div class="logo">Cottage<span>Book</span></div>
  </header>

  <main class="container">
    <section class="searchCard">
      <div class="tabs"><button class="tab active" type="button">Mediator</button></div>
      <h1 style="margin: 0 0 4px;">SSWAP Mediator</h1>
      <p class="intro">Align unknown cottage-booking ontologies on the fly. Step one analyses a remote RDG and stores the alignment. Step two reuses that alignment to invoke the service, transform the RRG, and render normalized booking suggestions.</p>
    </section>

    <section class="searchCard">
      <div class="tabs"><button class="tab active" type="button">Step 1 · Describe Remote Service</button></div>
      <p class="intro" style="margin-top:0">Provide the RDG endpoint and invoke URL of the remote SSWAP service. The mediator downloads the RDG, auto-suggests mappings, and lets you confirm or override each term.</p>
      <div class="mediatorGrid">
        <div class="mediatorPanel">
          <form id="alignmentForm">
            <div class="row">
              <label>RDG URL</label>
              <input name="rdg_url" value="http://127.0.0.1:8000/fake-remote/rdg" required />
            </div>
            <div class="row">
              <label>Invoke URL</label>
              <input name="service_url" value="http://127.0.0.1:8000/fake-remote/invoke" required />
            </div>
            <div class="actions">
              <button class="btn" type="button" id="previewAlignment">Fetch Remote RDG</button>
              <span id="alignmentStatus" class="statusLine"></span>
            </div>
          </form>
        </div>
        <div class="mediatorPanel">
          <div class="actions" style="justify-content: space-between; padding: 0;">
            <h3>Alignment Preview</h3>
            <button class="btn" id="saveAlignment" type="button" disabled>Save Alignment</button>
          </div>
          <div id="alignmentTable" style="flex:1;min-height:220px;"></div>
        </div>
      </div>
    </section>

    <section class="searchCard">
      <div class="tabs"><button class="tab active" type="button">Step 2 · Invoke Through Mediator</button></div>
      <p class="intro" style="margin-top:0">The mediator builds a RIG using the confirmed alignment, invokes the remote service, and transforms the RRG back into the native schema.</p>
      <div class="mediatorGrid">
        <div class="mediatorPanel">
          <form id="invokeForm">
            <div class="twoCol">
              <div class="row"><label>Booker Name</label><input name="booker_name" value="Alice" required /></div>
              <div class="row"><label>Required Places</label><input name="required_places" type="number" value="4" min="1" required /></div>
              <div class="row"><label>Bedrooms</label><input name="required_bedrooms" type="number" value="2" min="0" required /></div>
              <div class="row"><label>Max Distance to Lake (m)</label><input name="max_distance_lake_m" type="number" value="200" min="0" required /></div>
              <div class="row"><label>City</label><input name="city" value="Jyväskylä" required /></div>
              <div class="row"><label>Max Distance to City (m)</label><input name="max_distance_city_m" type="number" value="60000" min="0" required /></div>
              <div class="row"><label>Required Days</label><input name="required_days" type="number" value="3" min="1" required /></div>
              <div class="row"><label>Start Date</label><input name="start_date" type="date" required /></div>
              <div class="row"><label>Max Shift (± days)</label><input name="max_shift_days" type="number" value="2" min="0" required /></div>
            </div>
            <div class="actions">
              <button class="btn" type="submit">Invoke Remote Service</button>
              <span class="statusLine" id="invokeStatus"></span>
            </div>
          </form>
        </div>
        <div class="mediatorPanel">
          <h3>Normalized Suggestions</h3>
          <div id="remoteResults" class="results"></div>
        </div>
      </div>
      <div class="mediatorPanel" style="margin-top:20px;">
        <h3>Raw RRG (Transformed)</h3>
        <pre id="rrgRaw" class="mono"></pre>
      </div>
    </section>
  </main>

  <script>
  const LOCAL_INPUTS = {{ local_inputs | tojson }};
  const LOCAL_OUTPUTS = {{ local_outputs | tojson }};

  const alignmentForm = document.getElementById("alignmentForm");
  const previewBtn = document.getElementById("previewAlignment");
  const alignmentStatus = document.getElementById("alignmentStatus");
  const alignmentTable = document.getElementById("alignmentTable");
  const saveBtn = document.getElementById("saveAlignment");
  const invokeForm = document.getElementById("invokeForm");
  const invokeStatus = document.getElementById("invokeStatus");
  const remoteResults = document.getElementById("remoteResults");
  const rrgRaw = document.getElementById("rrgRaw");

  let currentPreview = [];

  async function readJsonResponse(resp) {
    const text = await resp.text();
    let parsed = null;
    if (text) {
      try {
        parsed = JSON.parse(text);
      } catch (err) {
        parsed = null;
      }
    }
    if (!resp.ok) {
      const detail = (parsed && parsed.detail) || text || resp.statusText;
      throw new Error(detail || "Unexpected server response.");
    }
    if (parsed === null) {
      throw new Error("Server returned invalid JSON.");
    }
    return parsed;
  }

  previewBtn.addEventListener("click", async () => {
    alignmentStatus.textContent = "Downloading RDG + calculating alignment...";
    alignmentTable.innerHTML = "";
    saveBtn.disabled = true;
    try {
      const payload = Object.fromEntries(new FormData(alignmentForm).entries());
      const resp = await fetch("/mediator/alignment/preview", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      const data = await readJsonResponse(resp);
      currentPreview = data.preview || [];
      renderAlignmentTable(currentPreview);
      alignmentStatus.textContent = `Preview ready (${currentPreview.length} terms). Confidence threshold = ${data.threshold}.`;
      saveBtn.disabled = false;
    } catch (err) {
      alignmentStatus.textContent = err.message;
    }
  });

  saveBtn.addEventListener("click", async () => {
    if (!currentPreview.length) return;
    alignmentStatus.textContent = "Saving alignment...";
    try {
      const rows = alignmentTable.querySelectorAll("tbody tr");
      const mappings = Array.from(rows).map(row => ({
        remote_uri: row.dataset.remoteUri,
        remote_name: row.dataset.remoteName,
        kind: row.dataset.kind,
        local: row.querySelector("select").value
      })).filter(item => item.local);
      const payload = Object.fromEntries(new FormData(alignmentForm).entries());
      payload.mappings = mappings;

      const resp = await fetch("/mediator/alignment/save", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      const data = await readJsonResponse(resp);
      alignmentStatus.textContent = `Alignment saved at ${data.saved_at}.`;
    } catch (err) {
      alignmentStatus.textContent = err.message;
    }
  });

  invokeForm.addEventListener("submit", async (e) => {
    e.preventDefault();
    invokeStatus.textContent = "Invoking remote service...";
    remoteResults.innerHTML = "";
    rrgRaw.textContent = "";
    try {
      const payload = Object.fromEntries(new FormData(invokeForm).entries());
      const serviceUrl = alignmentForm.querySelector("input[name='service_url']").value;
      payload.service_url = serviceUrl;

      const resp = await fetch("/mediator/invoke", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });
      const data = await readJsonResponse(resp);
      renderResults(data.suggestions || []);
      rrgRaw.textContent = data.raw_rrg || "";
      invokeStatus.textContent = `Received ${data.suggestions.length} suggestion(s).`;
    } catch (err) {
      invokeStatus.textContent = err.message;
    }
  });

  function renderAlignmentTable(items) {
    if (!items.length) {
      alignmentTable.innerHTML = "<p>No properties were found inside the RDG.</p>";
      return;
    }
    const rows = items.map(item => {
      const options = (item.kind === "input" ? LOCAL_INPUTS : LOCAL_OUTPUTS)
        .map(opt => {
          const selected = (item.current_local || item.suggested_local) === opt.key ? "selected" : "";
          return `<option value="${opt.key}" ${selected}>${opt.label}</option>`;
        }).join("");
      return `
        <tr data-remote-uri="${item.remote_uri}" data-remote-name="${item.remote_name}" data-kind="${item.kind}" class="${item.requires_confirmation ? "lowConfidence" : ""}">
          <td>${item.kind}</td>
          <td><code>${item.remote_name}</code></td>
          <td>${item.confidence}</td>
          <td><select><option value="">-- Select --</option>${options}</select></td>
        </tr>
      `;
    }).join("");
    alignmentTable.innerHTML = `
      <table class="alignment">
        <thead>
          <tr><th>Kind</th><th>Remote term</th><th>Similarity</th><th>Local property</th></tr>
        </thead>
        <tbody>${rows}</tbody>
      </table>
      <p><small>Orange rows require human confirmation because their similarity score is below the threshold.</small></p>
    `;
  }

  function renderResults(items) {
    if (!items.length) {
      remoteResults.innerHTML = '<div class="empty">No normalized suggestions available. Adjust filters or regenerate the alignment.</div>';
      return;
    }
    remoteResults.innerHTML = items.map(item => `
      <article class="card">
        <div class="content">
          <h3>${item.address}</h3>
          <div class="meta">
            <span>Booking <strong>#${item.booking_number}</strong></span>
            <span>${item.nearest_city} • ${item.distance_to_city_m} m to city</span>
          </div>
          <div class="facts">
            <span>${item.capacity} guests</span>
            <span>${item.bedrooms} bedrooms</span>
            <span>${item.booking_start} → ${item.booking_end}</span>
          </div>
          <div class="booker">Booker: <strong>${item.booker_name}</strong></div>
        </div>
      </article>
    `).join("");
  }

  const dateInput = invokeForm.querySelector("input[name='start_date']");
  if (dateInput && !dateInput.value) {
    const today = new Date().toISOString().slice(0, 10);
    dateInput.value = today;
  }
  </script>
</body>
</html>
